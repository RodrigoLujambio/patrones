<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Patrones de Dise√±o - Presentaci√≥n</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/black.css"
    />
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
    <style>
      section h2 {
        color: #ffd700;
        font-size: 1.5em;
      }
      section h3 {
        color: #00ced1;
        font-size: 1.3em;
      }
      section ul li,
      section p {
        color: #e0e0e0;
        font-size: 0.9em;
      }
      pre code {
        font-size: 0.8em;
      }
      table {
        font-size: 0.9em;
        color: #fff;
      }
      th,
      td {
        padding: 8px 12px;
        border: 1px solid #999;
      }
      table {
        border-collapse: collapse;
        margin: auto;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üåâ Patrones de Dise√±o</h1>
          <p style="color: #d3d3d3; font-size: 1em">
            DAO, Repository, Proxy, Decorator, Facade, Adapter, Bridge
          </p>
        </section>

        <!-- PATRON: Adapter -->
        <section><h2>üîå Adapter</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üîß El patr√≥n Adapter permite que dos interfaces incompatibles
            trabajen juntas. Act√∫a como un puente entre dos clases que no
            podr√≠an interactuar directamente debido a diferencias en sus
            interfaces.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s usar una clase existente pero su interfaz no
              coincide con lo que espera tu c√≥digo.
            </li>
            <li>
              Cuando necesit√°s integrar c√≥digo heredado o de terceros sin
              modificarlo.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li><strong>Target</strong>: La interfaz que espera el cliente.</li>
            <li>
              <strong>Adaptee</strong>: La clase existente con la funcionalidad
              deseada.
            </li>
            <li>
              <strong>Adapter</strong>: Traduce la interfaz de Adaptee a la del
              Target.
            </li>
          </ul>
        </section>

        <section>
          <h3>Clase Target</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Target: interfaz esperada por el cliente
class Printer {
  printMessage(msg) {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Clase Adaptee</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Adaptee: clase ya existente
class LegacyPrinter {
  oldPrint(msg) {
    console.log(">>> " + msg);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Clase Adapter</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Adapter: adapta LegacyPrinter a la interfaz esperada
class PrinterAdapter extends Printer {
  constructor() {
    super();
    this.legacy = new LegacyPrinter();
  }

  printMessage(msg) {
    this.legacy.oldPrint(msg);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Cliente usa el adapter sin saber que existe LegacyPrinter
const printer = new PrinterAdapter();
printer.printMessage("Hola mundo");
        </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas y ‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li><strong style="color: #90ee90">‚úÖ Ventajas</strong></li>
            <ul>
              <li>
                Te permite <strong>reutilizar c√≥digo existente</strong> sin
                modificarlo.
              </li>
              <li>A√≠sla cambios en la implementaci√≥n del c√≥digo cliente.</li>
              <li>Facilita la integraci√≥n de librer√≠as o sistemas legados.</li>
            </ul>
            <br />
            <li><strong style="color: #ffd700">‚ö†Ô∏è Desventajas</strong></li>
            <ul>
              <li>
                Puede <strong>agregar complejidad</strong> innecesaria si se
                abusa.
              </li>
              <li>
                En algunos lenguajes, puede implicar una
                <strong>carga extra de herencia o composici√≥n</strong>.
              </li>
            </ul>
          </ul>
        </section>

        <!-- PATRON: Bridge -->
        <section><h2>üåâ Bridge</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üß± El patr√≥n Bridge separa una abstracci√≥n de su implementaci√≥n,
            permitiendo que ambas evolucionen independientemente.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando ten√©s una jerarqu√≠a de clases que podr√≠a crecer en
              m√∫ltiples dimensiones.
            </li>
            <li>
              Cuando quer√©s combinar libremente una abstracci√≥n con diferentes
              implementaciones.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Abstraction</strong>: La interfaz de alto nivel para el
              cliente.
            </li>
            <li>
              <strong>Implementor</strong>: Define la interfaz de
              implementaci√≥n.
            </li>
            <li>
              <strong>ConcreteImplementor</strong>: Implementaciones concretas
              del implementor.
            </li>
            <li>
              <strong>RefinedAbstraction</strong>: Extiende la abstracci√≥n y
              delega a un implementor.
            </li>
          </ul>
        </section>

        <section>
          <h3>Clase Abstraction</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Abstraction: interfaz de alto nivel
class Shape {
  constructor(drawingAPI) {
    this.drawingAPI = drawingAPI;
  }

  draw() {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Clase RefinedAbstraction: Circle</h3>
          <pre><code class="language-js" data-trim data-noescape>
// RefinedAbstraction: extensi√≥n concreta de Shape
class Circle extends Shape {
  constructor(x, y, radius, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  draw() {
    this.drawingAPI.drawCircle(this.x, this.y, this.radius);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Otra RefinedAbstraction: Rect√°ngulo</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Otra forma que usa DrawingAPI
class Rectangle extends Shape {
  constructor(x, y, width, height, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  draw() {
    this.drawingAPI.drawRectangle(this.x, this.y, this.width, this.height);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Clase Implementor</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Implementor: define la interfaz de bajo nivel
class DrawingAPI {
  drawCircle(x, y, radius) {
    throw new Error("Este m√©todo debe ser implementado");
  }
  drawRectangle(x, y, width, height) {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteImplementor: CanvasAPI</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Implementaci√≥n concreta de DrawingAPI
class CanvasAPI extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`Canvas: Dibujo un c√≠rculo en (${x}, ${y}) con radio ${radius}`);
  }
  drawRectangle(x, y, width, height) {
    console.log(`Canvas: Dibujo un rect√°ngulo en (${x}, ${y}) de ${width}x${height}`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteImplementor: SVGAPI</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Otra implementaci√≥n concreta de DrawingAPI
class SVGAPI extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`<circle cx='${x}' cy='${y}' r='${radius}' />`);
  }
  drawRectangle(x, y, width, height) {
    console.log(`<rect x='${x}' y='${y}' width='${width}' height='${height}' />`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Ejemplos de uso</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Usar Circle con CanvasAPI
const canvasCircle = new Circle(10, 20, 5, new CanvasAPI());
canvasCircle.draw();

// Usar Circle con SVGAPI
const svgCircle = new Circle(0, 0, 10, new SVGAPI());
svgCircle.draw();

// Usar Rectangle con CanvasAPI
const rect = new Rectangle(5, 5, 20, 10, new CanvasAPI());
rect.draw();
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Desacopla <strong>abstracci√≥n</strong> e
              <strong>implementaci√≥n</strong>.
            </li>
            <li>
              Permite <strong>combinar libremente</strong> formas y m√©todos de
              renderizado (composici√≥n).
            </li>
            <li>
              Facilita la <strong>extensi√≥n</strong> sin modificar c√≥digo
              existente.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Introduce m√°s <strong>clases y capas</strong> (complejidad
              adicional).
            </li>
            <li>
              Puede parecer <strong>innecesario</strong> si la jerarqu√≠a no es
              grande.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Diferencia clave con Adapter</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Adapter</strong> adapta una interfaz existente para que
              sea compatible.
            </li>
            <li>
              <strong>Bridge</strong> separa dos jerarqu√≠as desde el dise√±o para
              que crezcan de forma independiente.
            </li>
          </ul>
        </section>

        <!-- PATRON: Decorator -->
        <section><h2>üéÅ Decorator</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            ‚ú® El patr√≥n Decorator permite agregar responsabilidades a un objeto
            de forma din√°mica, sin modificar su c√≥digo.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s agregar funcionalidades a objetos en tiempo de
              ejecuci√≥n.
            </li>
            <li>Cuando no pod√©s usar herencia para extender comportamiento.</li>
            <li>
              Cuando quer√©s mantener el principio de abierto/cerrado
              (Open/Closed).
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Component</strong>: Interfaz base que define la operaci√≥n.
            </li>
            <li>
              <strong>ConcreteComponent</strong>: Implementaci√≥n principal de
              esa interfaz.
            </li>
            <li>
              <strong>Decorator</strong>: Clase abstracta que implementa la
              interfaz y tiene una referencia al componente a decorar.
            </li>
            <li>
              <strong>ConcreteDecorators</strong>: Decoradores espec√≠ficos que
              agregan comportamiento.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componente base</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Component
class Notifier {
  send(message) {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Componente concreto</h3>
          <pre><code class="language-js" data-trim data-noescape>
// ConcreteComponent
class BasicNotifier extends Notifier {
  send(message) {
    console.log("Enviando mensaje:", message);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Decorator base</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Decorator base
class NotifierDecorator extends Notifier {
  constructor(notifier) {
    super();
    this.notifier = notifier;
  }

  send(message) {
    this.notifier.send(message);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteDecorator: Emoji</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Agrega emojis al mensaje
class EmojiDecorator extends NotifierDecorator {
  send(message) {
    super.send("üòÄ " + message + " üéâ");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteDecorator: Timestamp</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Agrega una marca de tiempo
class TimestampDecorator extends NotifierDecorator {
  send(message) {
    const timestamp = new Date().toISOString();
    super.send(`[${timestamp}] ${message}`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Composici√≥n din√°mica de decoradores
let notifier = new BasicNotifier();
notifier = new TimestampDecorator(notifier);
notifier = new EmojiDecorator(notifier);

notifier.send("¬°Hola mundo!");
// Resultado esperado:
// Enviando mensaje: üòÄ [2025-06-24T12:00:00.000Z] ¬°Hola mundo! üéâ
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Permite extender funcionalidades de manera flexible y
              <strong>din√°mica</strong>.
            </li>
            <li>
              Elimina la necesidad de
              <strong>crear muchas subclases</strong> para cada combinaci√≥n
              posible.
            </li>
            <li>
              Respeta el <strong>principio de responsabilidad √∫nica</strong>.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede generar <strong>muchos objetos anidados</strong> si se
              abusa.
            </li>
            <li>
              Puede ser m√°s dif√≠cil de <strong>depurar</strong> o entender que
              la herencia simple.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Diferencias con otros patrones</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Decorator vs Adapter</strong>: Adapter cambia la
              <strong>interfaz</strong>; Decorator
              <strong>agrega comportamiento</strong>.
            </li>
          </ul>
        </section>

        <!-- PATRON: Facade -->
        <section><h2>üè¢ Facade</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üéØ El patr√≥n Facade proporciona una interfaz simplificada a un
            conjunto complejo de clases o subsistemas.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>Cuando quer√©s ocultar la complejidad de un sistema interno.</li>
            <li>Cuando quer√©s desacoplar el cliente del sistema interno.</li>
            <li>
              Cuando trabaj√°s con bibliotecas o APIs con muchas dependencias.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li><strong>Facade</strong>: Interfaz de alto nivel.</li>
            <li>
              <strong>Subsistemas</strong>: Clases que hacen el trabajo real.
            </li>
            <li>
              <strong>Cliente</strong>: Usa el Facade en lugar de interactuar
              directamente con los subsistemas.
            </li>
          </ul>
        </section>

        <section>
          <h3>Clases del subsistema üé¨</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Amplifier {
  on() {
    console.log("Amplificador encendido");
  }
}

class StreamingPlayer {
  on() {
    console.log("Reproductor encendido");
  }
  play(movie) {
    console.log(`Reproduciendo ${movie}`);
  }
}

class TheaterLights {
  dim(level) {
    console.log(`Luces atenuadas a ${level}%`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Clase Facade: HomeTheaterFacade üçø</h3>
          <pre><code class="language-js" data-trim data-noescape>
class HomeTheaterFacade {
  constructor(amp, player, lights) {
    this.amp = amp;
    this.player = player;
    this.lights = lights;
  }

  watchMovie(movie) {
    console.log("Preparando para ver una pel√≠cula...");
    this.lights.dim(10);
    this.amp.on();
    this.player.on();
    this.player.play(movie);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Escenario sin Facade ‚ùå</h3>
          <pre><code class="language-js" data-trim data-noescape>
const amp = new Amplifier();
const player = new StreamingPlayer();
const lights = new TheaterLights();

lights.dim(10);
amp.on();
player.on();
player.play("Matrix");
// Dif√≠cil de mantener, propenso a errores,
// y repetitivo cada vez que se quiere reproducir una pel√≠cula
  </code></pre>
        </section>

        <section>
          <h3>Uso con Facade ‚úÖ</h3>
          <pre><code class="language-js" data-trim data-noescape>
const amp = new Amplifier();
const player = new StreamingPlayer();
const lights = new TheaterLights();

const homeTheater = new HomeTheaterFacade(amp, player, lights);
homeTheater.watchMovie("Matrix");

// Resultado:
// Preparando para ver una pel√≠cula...
// Luces atenuadas a 10%
// Amplificador encendido
// Reproductor encendido
// Reproduciendo Matrix
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li><strong>Oculta la complejidad</strong> del sistema.</li>
            <li>
              Reduce el <strong>acoplamiento</strong> entre cliente y
              subsistema.
            </li>
            <li>
              Mejora la <strong>legibilidad y mantenibilidad</strong> del c√≥digo
              cliente.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede convertirse en una <strong>‚Äúclase dios‚Äù</strong> si se
              abusa.
            </li>
            <li>
              No impide al cliente seguir accediendo al subsistema directamente
              (si no se controla).
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Comparaciones</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Facade vs Adapter:</strong>
              <ul>
                <li>
                  <em>Facade</em> simplifica una interfaz
                  <strong>compleja existente</strong>.
                </li>
                <li>
                  <em>Adapter</em> convierte una
                  <strong>interfaz incompatible</strong> en una que el cliente
                  espera.
                </li>
              </ul>
            </li>
            <li>
              <strong>Facade vs Decorator:</strong>
              <ul>
                <li>
                  <em>Decorator</em> a√±ade <strong>comportamiento</strong>.
                </li>
                <li><em>Facade</em> oculta <strong>complejidad</strong>.</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- PATRON: Proxy -->
        <section><h2>üõ°Ô∏è Proxy</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üïµÔ∏è‚Äç‚ôÇÔ∏è El patr√≥n Proxy provee un objeto sustituto que controla el acceso
            a otro objeto.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>Para controlar el acceso a un objeto costoso o sensible.</li>
            <li>
              Para agregar l√≥gica adicional (logs, control de acceso, cache) sin
              modificar el objeto real.
            </li>
            <li>Para cargar objetos de manera diferida (lazy loading).</li>
          </ul>
        </section>

        <section>
          <h3>Tipos de Proxy üîÄ</h3>
          <ul>
            <li>
              <strong>Proxy de protecci√≥n</strong>: Controla permisos de acceso.
            </li>
            <li>
              <strong>Proxy virtual</strong>: Crea objetos costosos bajo
              demanda.
            </li>
            <li>
              <strong>Proxy remoto</strong>: Representa un objeto que est√° en
              otra m√°quina.
            </li>
            <li>
              <strong>Proxy de cach√©</strong>: Guarda resultados para
              reutilizarlos.
            </li>
            <li>
              <strong>Proxy inteligente</strong>: Agrega l√≥gica adicional como
              logging o conteo de referencias.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Subject</strong>: Interfaz com√∫n para el RealSubject y el
              Proxy.
            </li>
            <li>
              <strong>RealSubject</strong>: El objeto real al que se accede.
            </li>
            <li><strong>Proxy</strong>: Controla el acceso al RealSubject.</li>
          </ul>
        </section>

        <section>
          <h3>Interfaz Subject</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Video {
  constructor(filename) {
    this.filename = filename;
    this.load();
  }

  load() {
    console.log(`Cargando video desde ${this.filename}...`);
  }

  play() {
    console.log(`Reproduciendo ${this.filename}`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Proxy: Proxy que retrasa la carga de video</h3>
          <pre><code class="language-js" data-trim data-noescape>
class VideoProxy {
  constructor(filename) {
    this.filename = filename;
    this.realVideo = null;
  }

  play() {
    if (!this.realVideo) {
      this.realVideo = new Video(this.filename); // carga solo al primer uso
    }
    this.realVideo.play();
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const video = new VideoProxy("pelicula.mp4");
console.log("Video creado pero no cargado a√∫n");
video.play(); // aqu√≠ reci√©n se carga y reproduce
video.play(); // ya est√° cargado, se reproduce directamente
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Permite <strong>controlar el acceso</strong> a objetos costosos o
              sensibles.
            </li>
            <li>
              Agrega <strong>funcionalidad extra</strong> como logs, control de
              acceso o cache.
            </li>
            <li>Permite <strong>lazy loading</strong> (carga diferida).</li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede
              <strong>introducir una capa de complejidad</strong> adicional.
            </li>
            <li>
              Si no est√° bien dise√±ado, puede
              <strong>afectar el rendimiento</strong>.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Comparaciones</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Proxy vs Decorator:</strong> Proxy
              <strong>controla acceso</strong>; Decorator
              <strong>agrega comportamiento</strong>.
            </li>
            <li>
              <strong>Proxy vs Adapter:</strong> Adapter
              <strong>transforma interfaces</strong>; Proxy
              <strong>intercepta y decide acceso</strong>.
            </li>
          </ul>
        </section>

        <!-- PATRON: DAO -->
        <section><h2>üìÇ DAO (Data Access Object)</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üìÅ El patr√≥n DAO encapsula el acceso a datos, separando la l√≥gica de
            negocio de la l√≥gica de persistencia.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s desacoplar tu l√≥gica de negocio del acceso a la base
              de datos.
            </li>
            <li>
              Cuando quer√©s facilitar el testeo o intercambiar mecanismos de
              persistencia.
            </li>
            <li>Cuando ten√©s m√∫ltiples fuentes de datos o repositorios.</li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>DAO</strong>: Define los m√©todos para acceder y modificar
              datos.
            </li>
            <li>
              <strong>Entidad</strong>: Representa la estructura de datos.
            </li>
            <li>
              <strong>Implementaci√≥n concreta</strong>: L√≥gica espec√≠fica de
              almacenamiento.
            </li>
            <li>
              <strong>Servicio/Cliente</strong>: Usa el DAO sin saber c√≥mo se
              persisten los datos.
            </li>
          </ul>
        </section>

        <section>
          <h3>Entidad: Usuario</h3>
          <pre><code class="language-js" data-trim data-noescape>
class User {
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Interfaz DAO</h3>
          <pre><code class="language-js" data-trim data-noescape>
class UserDAO {
  getAll() {
    throw new Error("No implementado");
  }
  getById(id) {
    throw new Error("No implementado");
  }
  save(user) {
    throw new Error("No implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Implementaci√≥n concreta (en memoria)</h3>
          <pre><code class="language-js" data-trim data-noescape>
class InMemoryUserDAO extends UserDAO {
  constructor() {
    super();
    this.users = [];
  }

  getAll() {
    return this.users;
  }

  getById(id) {
    return this.users.find(u => u.id === id);
  }

  save(user) {
    this.users.push(user);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const dao = new InMemoryUserDAO();

dao.save(new User(1, "Alice"));
dao.save(new User(2, "Bob"));

console.log(dao.getAll());
console.log(dao.getById(2));

// Resultado esperado:
// [ User { id: 1, name: 'Alice' }, User { id: 2, name: 'Bob' } ]
// User { id: 2, name: 'Bob' }
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Separa <strong>l√≥gica de acceso a datos</strong> de la l√≥gica de
              negocio.
            </li>
            <li>Facilita <strong>el testeo</strong> y el mantenimiento.</li>
            <li>
              Permite <strong>cambiar el mecanismo de persistencia</strong> sin
              modificar el resto del sistema.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede resultar en <strong>clases repetitivas</strong> si no se
              abstraen bien.
            </li>
            <li>
              Puede ser <strong>innecesario</strong> en aplicaciones peque√±as o
              muy simples.
            </li>
          </ul>
        </section>

        <!-- PATRON: Repository -->
        <section><h2>üì¶ Repository</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üìö El patr√≥n Repository act√∫a como una colecci√≥n en memoria,
            permitiendo acceder a objetos sin exponer detalles de
            almacenamiento. A√≠sla la l√≥gica de acceso a datos del resto de la
            aplicaci√≥n.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s abstraer la l√≥gica de consulta y persistencia.
            </li>
            <li>Cuando trabaj√°s con modelos de dominio complejos.</li>
            <li>
              Cuando quer√©s desacoplar servicios de la l√≥gica de almacenamiento.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Repositorio</strong>: Provee operaciones sobre entidades
              del dominio.
            </li>
            <li>
              <strong>Entidad</strong>: Modelo del dominio que se gestiona.
            </li>
            <li>
              <strong>Fuente de datos</strong>: Base de datos, servicio externo,
              o DAO.
            </li>
          </ul>
        </section>

        <section>
          <h3>Entidad: Product</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Product {
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Repositorio sin DAO ‚ùå</h3>
          <pre><code class="language-js" data-trim data-noescape>
class ProductRepository {
  constructor() {
    this.products = [];
  }

  findAll() {
    return this.products;
  }

  findById(id) {
    return this.products.find(p => p.id === id);
  }

  save(product) {
    this.products.push(product);
  }
}

const repo = new ProductRepository();
repo.save(new Product(1, "Silla"));
repo.save(new Product(2, "Mesa"));

console.log(repo.findAll());
console.log(repo.findById(2));
  </code></pre>
        </section>

        <section>
          <h3>DAO para productos</h3>
          <pre><code class="language-js" data-trim data-noescape>
class ProductDAO {
  constructor() {
    this.storage = [];
  }

  getAll() {
    return this.storage;
  }

  getById(id) {
    return this.storage.find(p => p.id === id);
  }

  save(product) {
    this.storage.push(product);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Repositorio con DAO ‚úÖ</h3>
          <pre><code class="language-js" data-trim data-noescape>

// Repository que usa DAO
class ProductRepository {
  constructor(dao) {
    this.dao = dao;
  }

  getAllProducts() {
    return this.dao.getAll();
  }

  getProductById(id) {
    return this.dao.getById(id);
  }

  addProduct(product) {
    this.dao.save(product);
  }
}

const dao = new ProductDAO();
const repository = new ProductRepository(dao);

repository.addProduct(new Product(1, "L√°mpara"));
repository.addProduct(new Product(2, "Sof√°"));

console.log(repository.getAllProducts());
console.log(repository.getProductById(1));
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>Encapsula la l√≥gica de acceso y consulta.</li>
            <li>
              Ofrece una <strong>API coherente</strong> para trabajar con
              objetos del dominio.
            </li>
            <li>Facilita pruebas y mantenimiento.</li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>Puede duplicar trabajo si ya se usa un ORM sofisticado.</li>
            <li>
              Agrega una capa m√°s que puede <strong>no ser necesaria</strong> en
              sistemas simples.
            </li>
          </ul>
        </section>

        <!-- Aqu√≠ seguir√°n los dem√°s patrones -->

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">
            üåâ Patrones de Dise√±o 2
          </h1>
          <p style="color: #d3d3d3; font-size: 1em">
            CoR, Command, Mediator, Memento, State, Strategy, Visitor
          </p>
        </section>

        <!-- PATRON: CoR -->
        <section><h2>Chain of Responsability</h2></section>

        <section>
          <h3>Clase Handler</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Handler base
class Handler {
  setNext(handler) {
    this.next = handler;
    return handler;
  }

  handle(request) {
    if (this.next) {
      return this.next.handle(request);
    }

    return null;
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Handlers Concretos</h3>
          <pre><code class="language-js" data-trim data-noescape>
class SupportHandler extends Handler {
  handle(request) {
    if (request.type === "soporte") {
      return "üéß Soporte t√©cnico respondi√≥ tu solicitud";
    }
    return super.handle(request);
  }
}

class BillingHandler extends Handler {
  handle(request) {
    if (request.type === "factura") {
      return "üí∞ Facturaci√≥n proces√≥ tu solicitud";
    }
    return super.handle(request);
  }
}

class GeneralHandler extends Handler {
  handle(request) {
    return "üì® Derivado a atenci√≥n general";
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso</h3>
          <pre><code class="language-js" data-trim data-noescape>
const soporte = new SupportHandler();
const facturacion = new BillingHandler();
const general = new GeneralHandler();

soporte.setNext(facturacion).setNext(general);

console.log(soporte.handle({ type: "soporte" }));
// üéß Soporte t√©cnico respondi√≥ tu solicitud

console.log(soporte.handle({ type: "factura" }));
// üí∞ Facturaci√≥n proces√≥ tu solicitud

console.log(soporte.handle({ type: "otro" }));
// üì® Derivado a atenci√≥n general
        </code></pre>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n Chain of Responsibility (Cadena de Responsabilidad) es un
            patr√≥n de comportamiento que permite que varios objetos tengan la
            oportunidad de manejar una solicitud, sin que el emisor de la
            solicitud conozca cu√°l objeto la va a procesar. Los objetos est√°n
            encadenados y la solicitud se pasa por la cadena hasta que un objeto
            la maneja.
          </p>
        </section>

        <section>
          <h3>üß± ¬øC√≥mo funciona?</h3>
          <p>Cada objeto de la cadena:</p>
          <ul>
            <li>Decide si maneja la solicitud o</li>
            <li>La pasa al siguiente en la cadena</li>
          </ul>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s desacoplar el emisor de la solicitud de los
              receptores.
            </li>
            <li>Cuando m√°s de un objeto puede manejar una solicitud.</li>
            <li>
              Cuando quer√©s flexibilidad al agregar nuevos manejadores sin
              modificar c√≥digo existente.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Handler</strong>: Interfaz que define el contrato de
              manejo y referencia al siguiente.
            </li>
            <li>
              <strong>Concrete Handler</strong>: Implementa la l√≥gica de manejo.
              Si no puede manejar, delega.
            </li>
            <li><strong>Client</strong>: Crea y configura la cadena.</li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas y ‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li><strong style="color: #90ee90">‚úÖ Ventajas</strong></li>
            <ul>
              <li>Desacopla el emisor del receptor.</li>
              <li>F√°cil de extender agregando nuevos manejadores.</li>
              <li>Permite control din√°mico del flujo.</li>
            </ul>
            <br />
            <li><strong style="color: #ffd700">‚ö†Ô∏è Desventajas</strong></li>
            <ul>
              <li>Puede ser dif√≠cil de seguir si la cadena es muy larga.</li>
              <li>No garantiza que alguien maneje la solicitud.</li>
            </ul>
          </ul>
        </section>

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üéÆ Command</h1>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n <strong>Command</strong> encapsula una solicitud como un
            objeto, permitiendo parametrizar acciones, soportar operaciones
            deshacer (undo), y almacenar historial.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>Cuando quer√©s encapsular acciones como objetos.</li>
            <li>
              Cuando necesit√°s operaciones <strong>deshacer/rehacer</strong> o
              mantener un historial.
            </li>
            <li>
              Cuando quer√©s <strong>desacoplar</strong> el objeto que env√≠a la
              solicitud del que la ejecuta.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Command</strong>: Interfaz con m√©todo
              <code>execute()</code>.
            </li>
            <li>
              <strong>ConcreteCommand</strong>: Implementa
              <code>execute()</code> y llama al receptor.
            </li>
            <li><strong>Receiver</strong>: Hace el trabajo real.</li>
            <li><strong>Invoker</strong>: Llama al comando.</li>
            <li><strong>Client</strong>: Configura todo.</li>
          </ul>
        </section>

        <section>
          <h3>Receiver: Light</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Light {
  on() {
    console.log("üí° Luz encendida");
  }
  off() {
    console.log("üåë Luz apagada");
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Interfaz Command</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Command {
  execute() {}
}
        </code></pre>
        </section>

        <section>
          <h3>LightOnCommand</h3>
          <pre><code class="language-js" data-trim data-noescape>
class LightOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  execute() {
    this.light.on();
  }
}
        </code></pre>
        </section>

        <section>
          <h3>LightOffCommand</h3>
          <pre><code class="language-js" data-trim data-noescape>
class LightOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  execute() {
    this.light.off();
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Invoker: RemoteControl</h3>
          <pre><code class="language-js" data-trim data-noescape>
class RemoteControl {
  setCommand(command) {
    this.command = command;
  }
  pressButton() {
    this.command.execute();
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const light = new Light();
const onCommand = new LightOnCommand(light);
const offCommand = new LightOffCommand(light);

const remote = new RemoteControl();

remote.setCommand(onCommand);
remote.pressButton(); // üí° Luz encendida

remote.setCommand(offCommand);
remote.pressButton(); // üåë Luz apagada
        </code></pre>
        </section>

        <section>
          <h3>‚úÖ Ventajas</h3>
          <ul>
            <li>Desacopla el invocador del receptor.</li>
            <li>Permite <strong>guardar historial</strong> de comandos.</li>
            <li>
              Soporta operaciones <strong>undo</strong> y <strong>redo</strong>.
            </li>
            <li>Permite <strong>encolar comandos</strong>.</li>
          </ul>
        </section>

        <section>
          <h3>‚ö†Ô∏è Desventajas</h3>
          <ul>
            <li>Aumenta la <strong>cantidad de clases</strong>.</li>
            <li>
              Puede ser excesivo si solo se necesita una simple llamada a
              m√©todo.
            </li>
          </ul>
        </section>

        <section>
          <h3>üÜö Comparaciones con otros patrones</h3>
          <table>
            <thead>
              <tr>
                <th>Patr√≥n</th>
                <th>¬øQu√© encapsula?</th>
                <th>¬øCu√°ndo usarlo?</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Command</strong></td>
                <td>Una operaci√≥n</td>
                <td>Deshacer, historial, ejecuci√≥n tard√≠a</td>
              </tr>
              <tr>
                <td><strong>Strategy</strong></td>
                <td>Un algoritmo completo</td>
                <td>Variar comportamiento</td>
              </tr>
              <tr>
                <td><strong>Observer</strong></td>
                <td>Reacci√≥n a eventos</td>
                <td>Notificaciones m√∫ltiples</td>
              </tr>
            </tbody>
          </table>
        </section>

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üëÄ Observer</h1>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n <strong>Observer</strong> define una dependencia
            uno-a-muchos entre objetos, de modo que cuando un objeto cambia de
            estado, todos sus dependientes son notificados autom√°ticamente.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando m√∫ltiples objetos deben reaccionar a un cambio en otro
              objeto.
            </li>
            <li>
              Cuando quer√©s <strong>desacoplar</strong> al sujeto de sus
              observadores.
            </li>
            <li>
              Ideal para sistemas de
              <strong>eventos, UIs, modelos de datos</strong>, etc.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Subject</strong>: Mantiene una lista de observadores y los
              notifica.
            </li>
            <li>
              <strong>Observer</strong>: Interfaz con el m√©todo
              <code>update()</code>.
            </li>
            <li>
              <strong>ConcreteObserver</strong>: Implementa
              <code>update()</code> y reacciona al cambio.
            </li>
          </ul>
        </section>

        <section>
          <h3>Subject</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(o => o !== observer);
  }

  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Observer</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Observer {
  update(data) {
    // debe ser implementado por los observadores concretos
  }
}
        </code></pre>
        </section>

        <section>
          <h3>ConcreteObserver</h3>
          <pre><code class="language-js" data-trim data-noescape>
class LoggerObserver extends Observer {
  update(data) {
    console.log("üìù Log recibido:", data);
  }
}

class AlertObserver extends Observer {
  update(data) {
    alert("üîî Nueva alerta: " + data);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const subject = new Subject();
const logger = new LoggerObserver();
const alerter = new AlertObserver();

subject.subscribe(logger);
subject.subscribe(alerter);

subject.notify("Temperatura cr√≠tica");
//Resultado esperado: 
üìù Log recibido: Temperatura cr√≠tica
üîî Nueva alerta: Temperatura cr√≠tica
        </code></pre>
        </section>

        <section>
          <h3>‚úÖ Ventajas</h3>
          <ul>
            <li>Desacopla al sujeto de los observadores.</li>
            <li>Permite agregar nuevos observadores en tiempo de ejecuci√≥n.</li>
            <li>Ideal para sistemas de notificaci√≥n y eventos.</li>
          </ul>
        </section>

        <section>
          <h3>‚ö†Ô∏è Desventajas</h3>
          <ul>
            <li>Puede ser dif√≠cil de depurar si hay muchos observadores.</li>
            <li>Orden de notificaci√≥n no est√° garantizado.</li>
            <li>
              Los observadores pueden afectar el rendimiento si realizan tareas
              pesadas.
            </li>
          </ul>
        </section>

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üß© Mediator</h1>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n <strong>Mediator</strong> centraliza la comunicaci√≥n entre
            varios objetos, reduciendo el acoplamiento entre ellos. En lugar de
            que los objetos se referencien entre s√≠, lo hacen a trav√©s de un
            mediador.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando varios objetos se comunican de forma compleja entre s√≠.
            </li>
            <li>Cuando quer√©s centralizar la l√≥gica de interacci√≥n.</li>
            <li>Ideal en interfaces gr√°ficas, chats, y componentes UI.</li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Mediator</strong>: Interfaz para comunicaci√≥n entre
              colegas.
            </li>
            <li>
              <strong>ConcreteMediator</strong>: Implementa la l√≥gica de
              coordinaci√≥n.
            </li>
            <li>
              <strong>Colleague</strong>: Interfaz base de objetos que
              interact√∫an.
            </li>
            <li>
              <strong>ConcreteColleague</strong>: Objeto que se comunica a
              trav√©s del mediador.
            </li>
          </ul>
        </section>

        <section>
          <h3>Colleague (interfaz base)</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Colleague {
  constructor(mediator) {
    this.mediator = mediator;
  }
  send(message) {}
  receive(message) {}
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteColleague</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Button extends Colleague {
  constructor(mediator) {
    super(mediator);
  }
  click() {
    console.log("üîò Bot√≥n clickeado");
    this.mediator.notify(this, "click");
  }
  receive(message) {
    console.log("Bot√≥n recibi√≥:", message);
  }
}

class TextBox extends Colleague {
  constructor(mediator) {
    super(mediator);
  }
  setText(text) {
    console.log("üì• TextBox actualizado:", text);
  }
  receive(message) {
    this.setText(message);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Mediator</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Mediador
class Mediator {
  notify(sender, event) {
    throw new Error("Debe implementarse en subclase");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteMediator</h3>
          <pre><code class="language-js" data-trim data-noescape>
class FormMediator extends Mediator {
  constructor() {
    this.button = null;
    this.textBox = null;
  }

  registerButton(button) {
    this.button = button;
  }

  registerTextBox(textBox) {
    this.textBox = textBox;
  }

  notify(sender, event) {
    if (sender === this.button && event === "click") {
      this.textBox.receive("Formulario enviado");
    }
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const mediator = new FormMediator();

const button = new Button(mediator);
const textBox = new TextBox(mediator);

mediator.registerButton(button);
mediator.registerTextBox(textBox);

button.click();
//Resultado Esperado:
üîò Bot√≥n clickeado
üì• TextBox actualizado: Formulario enviado
  </code></pre>
        </section>

        <section>
          <h3>‚úÖ Ventajas</h3>
          <ul>
            <li>Reduce dependencias entre componentes.</li>
            <li>Centraliza la l√≥gica de interacci√≥n.</li>
            <li>Facilita mantenimiento y pruebas.</li>
          </ul>
        </section>

        <section>
          <h3>‚ö†Ô∏è Desventajas</h3>
          <ul>
            <li>Puede volverse un <strong>objeto muy complejo</strong>.</li>
            <li>A√±ade una capa de indirecci√≥n.</li>
          </ul>
        </section>

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üß† Memento</h1>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n <strong>Memento</strong> permite capturar y almacenar el
            estado interno de un objeto sin violar el encapsulamiento, de modo
            que el objeto pueda volver a ese estado m√°s adelante.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando necesit√°s implementar <strong>deshacer (undo)</strong>.
            </li>
            <li>
              Cuando quer√©s <strong>preservar el estado interno</strong> de un
              objeto sin exponer su estructura.
            </li>
            <li>
              Cuando trabaj√°s con editores, juegos, formularios complejos, etc.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Originator</strong>: El objeto cuyo estado queremos
              guardar.
            </li>
            <li>
              <strong>Memento</strong>: Objeto que almacena el estado del
              originador.
            </li>
            <li>
              <strong>Caretaker</strong>: Responsable de guardar y restaurar los
              mementos.
            </li>
          </ul>
        </section>

        <section>
          <h3>Originator</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Editor {
  constructor() {
    this.content = "";
  }

  write(text) {
    this.content += text;
  }

  save() {
    return new Memento(this.content);
  }

  restore(memento) {
    this.content = memento.getState();
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Memento</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Memento {
  constructor(state) {
    this.state = state;
  }

  getState() {
    return this.state;
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Caretaker</h3>
          <pre><code class="language-js" data-trim data-noescape>
class History {
  constructor() {
    this.stack = [];
  }

  push(memento) {
    this.stack.push(memento);
  }

  pop() {
    return this.stack.pop();
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const editor = new Editor();
const history = new History();

editor.write("Hola ");
history.push(editor.save());

editor.write("Mundo!");
console.log(editor.content); // Hola Mundo!

editor.restore(history.pop());
console.log(editor.content); // Hola
//Resultado Esperado:
Hola Mundo!
Hola
  </code></pre>
        </section>

        <section>
          <h3>‚úÖ Ventajas</h3>
          <ul>
            <li>No rompe el <strong>encapsulamiento</strong>.</li>
            <li>Permite implementar <strong>deshacer</strong> f√°cilmente.</li>
            <li>Muy √∫til para editores de texto, juegos, formularios, etc.</li>
          </ul>
        </section>

        <section>
          <h3>‚ö†Ô∏è Desventajas</h3>
          <ul>
            <li>
              Puede consumir mucha <strong>memoria</strong> si se guardan muchos
              estados.
            </li>
            <li>
              El <strong>caretaker</strong> debe manejar la gesti√≥n del ciclo de
              vida de los mementos.
            </li>
          </ul>
        </section>

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üîÅ State</h1>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n <strong>State</strong> permite a un objeto cambiar su
            comportamiento cuando cambia su estado interno. El objeto parecer√°
            cambiar su clase.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando un objeto debe cambiar su comportamiento dependiendo de su
              estado.
            </li>
            <li>
              Cuando hay muchas estructuras <code>if/else</code> o
              <code>switch</code> basadas en estados.
            </li>
            <li>
              Cuando un objeto debe cambiar su comportamiento de manera din√°mica
              en tiempo de ejecuci√≥n, en funci√≥n de ciertas condiciones.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Context</strong>: Mantiene una referencia al estado
              actual.
            </li>
            <li>
              <strong>State</strong>: Interfaz com√∫n para todos los estados.
            </li>
            <li>
              <strong>ConcreteState</strong>: Implementaciones concretas del
              comportamiento en cada estado.
            </li>
          </ul>
        </section>

        <section>
          <h3>State (interfaz)</h3>
          <pre><code class="language-js" data-trim data-noescape>
class State {
  handle(context) {
    throw new Error("Debe implementarse");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteStates</h3>
          <pre><code class="language-js" data-trim data-noescape>
class HappyState extends State {
  handle(context) {
    console.log("üòÄ Estoy feliz!");
    context.setState(new SadState());
  }
}

class SadState extends State {
  handle(context) {
    console.log("üò¢ Estoy triste...");
    context.setState(new HappyState());
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Context</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Person {
  constructor() {
    this.state = new HappyState();
  }

  setState(state) {
    this.state = state;
  }

  react() {
    this.state.handle(this);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const person = new Person();

person.react(); // üòÄ Estoy feliz!
person.react(); // üò¢ Estoy triste...
person.react(); // üòÄ Estoy feliz!
  </code></pre>
        </section>

        <section>
          <h3>‚úÖ Ventajas</h3>
          <ul>
            <li>Elimina estructuras de control repetitivas.</li>
            <li>Encapsula comportamientos espec√≠ficos de cada estado.</li>
            <li>Facilita la adici√≥n de nuevos estados.</li>
          </ul>
        </section>

        <section>
          <h3>‚ö†Ô∏è Desventajas</h3>
          <ul>
            <li>
              Aumenta la cantidad de clases, dado que obliga que cada estado
              posible sea una clase.
            </li>
            <li>Puede ser innecesario si solo hay pocos estados simples.</li>
          </ul>
        </section>

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üßÆ Strategy</h1>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n <strong>Strategy</strong> define una familia de
            algoritmos, los encapsula y los hace intercambiables. Permite que el
            algoritmo var√≠e independientemente del cliente que lo utiliza.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s seleccionar un algoritmo en tiempo de ejecuci√≥n.
            </li>
            <li>Cuando m√∫ltiples clases difieren solo en su comportamiento.</li>
            <li>
              Cuando ten√©s muchas estructuras <code>if/else</code> con
              diferentes estrategias.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Strategy</strong>: Interfaz com√∫n para todas las
              estrategias.
            </li>
            <li>
              <strong>ConcreteStrategy</strong>: Implementaciones concretas de
              la estrategia.
            </li>
            <li>
              <strong>Context</strong>: Utiliza una estrategia para ejecutar el
              algoritmo.
            </li>
          </ul>
        </section>

        <section>
          <h3>Strategy (interfaz)</h3>
          <pre><code class="language-js" data-trim data-noescape>
class PaymentStrategy {
  pay(amount) {
    throw new Error("Debe implementarse");
  }
}
        </code></pre>
        </section>

        <section>
          <h3>ConcreteStrategies</h3>
          <pre><code class="language-js" data-trim data-noescape>
class CreditCardPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`üí≥ Pagando $${amount} con tarjeta de cr√©dito`);
  }
}

class PayPalPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`üìß Pagando $${amount} con PayPal`);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Context</h3>
          <pre><code class="language-js" data-trim data-noescape>
class PaymentContext {
  constructor(strategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy) {
    this.strategy = strategy;
  }

  execute(amount) {
    this.strategy.pay(amount);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const payment1 = new PaymentContext(new CreditCardPayment());
payment1.execute(100); // üí≥ Pagando $100 con tarjeta de cr√©dito

const payment2 = new PaymentContext(new PayPalPayment());
payment2.execute(200); // üìß Pagando $200 con PayPal
        </code></pre>
        </section>

        <section>
          <h3>Otro ejemplo: Estrategias para √°rea de tri√°ngulo</h3>
          <p>
            Se encapsulan dos algoritmos distintos para calcular el √°rea de un
            tri√°ngulo.
          </p>
        </section>

        <section>
          <h3>Interfaz AreaStrategy</h3>
          <pre><code class="language-js" data-trim data-noescape>
class AreaStrategy {
  area() {
    throw new Error("Debe implementarse");
  }
}
        </code></pre>
        </section>

        <section>
          <h3>ConcreteStrategy: Base x Altura / 2</h3>
          <pre><code class="language-js" data-trim data-noescape>
class BaseHeightArea extends AreaStrategy {
  area(base, height) {
    return (base * height) / 2;
  }
}
        </code></pre>
        </section>

        <section>
          <h3>ConcreteStrategy: F√≥rmula de Her√≥n</h3>
          <pre><code class="language-js" data-trim data-noescape>
class HeronArea extends AreaStrategy {
  area(a, b, c) {
    const s = (a + b + c) / 2;
    return Math.sqrt(s * (s - a) * (s - b) * (s - c));
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Context: TriangleAreaContext</h3>
          <pre><code class="language-js" data-trim data-noescape>
class TriangleAreaContext {
  constructor(strategy) {
    this.strategy = strategy;
  }
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  area(...args) {
    return this.strategy.area(...args);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const triangle1 = new TriangleAreaContext(new BaseHeightArea());
console.log(triangle1.area(6, 4)); // 12

const triangle2 = new TriangleAreaContext(new HeronArea());
console.log(triangle2.area(5, 5, 6)); // 12
        </code></pre>
        </section>

        <section>
          <h3>‚úÖ Ventajas</h3>
          <ul>
            <li>Permite cambiar algoritmos en tiempo de ejecuci√≥n.</li>
            <li>Elimina estructuras de control complejas.</li>
            <li>F√°cil de extender con nuevas estrategias.</li>
          </ul>
        </section>

        <section>
          <h3>‚ö†Ô∏è Desventajas</h3>
          <ul>
            <li>Aumenta el n√∫mero de clases.</li>
            <li>El cliente debe conocer las diferencias entre estrategias.</li>
          </ul>
        </section>

        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üß≠ Visitor</h1>
        </section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            El patr√≥n <strong>Visitor</strong> permite agregar nuevas
            operaciones a estructuras de objetos existentes sin modificar sus
            clases.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando necesit√°s realizar operaciones sobre una estructura de
              objetos compleja.
            </li>
            <li>Cuando quer√©s mantener separado el algoritmo del objeto.</li>
            <li>
              Cuando agregar una operaci√≥n directamente a una clase romper√≠a el
              principio de responsabilidad √∫nica.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Visitor</strong>: Interfaz que declara una operaci√≥n por
              cada tipo de elemento.
            </li>
            <li>
              <strong>ConcreteVisitor</strong>: Implementa las operaciones.
            </li>
            <li>
              <strong>Element</strong>: Interfaz con un m√©todo
              <code>accept(visitor)</code>.
            </li>
            <li>
              <strong>ConcreteElement</strong>: Implementa <code>accept</code> y
              llama a <code>visitor.visit(this)</code>.
            </li>
            <li>
              <strong>ObjectStructure</strong>: Colecci√≥n de elementos a los que
              se aplica el visitante.
            </li>
          </ul>
        </section>

        <section>
          <h3>Visitor y Element (interfaces)</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Visitor {
  visitCircle(circle) {}
  visitRectangle(rectangle) {}
}

class Shape {
  accept(visitor) {
    throw new Error("Debe implementarse");
  }
}
        </code></pre>
        </section>

        <section>
          <h3>ConcreteElements</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  accept(visitor) {
    visitor.visitCircle(this);
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  accept(visitor) {
    visitor.visitRectangle(this);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>ConcreteVisitor</h3>
          <pre><code class="language-js" data-trim data-noescape>
class AreaCalculator extends Visitor {
  visitCircle(circle) {
    const area = Math.PI * circle.radius ** 2;
    console.log(`üîµ √Årea del c√≠rculo: ${area.toFixed(2)}`);
  }
  visitRectangle(rectangle) {
    const area = rectangle.width * rectangle.height;
    console.log(`üü¶ √Årea del rect√°ngulo: ${area}`);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>ObjectStructure</h3>
          <pre><code class="language-js" data-trim data-noescape>
class ObjectStructure {
  constructor() {
    this.elements = [];
  }

  addElement(element) {
    this.elements.push(element);
  }

  accept(visitor) {
    for (const element of this.elements) {
      element.accept(visitor);
    }
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const structure = new ObjectStructure();
structure.addElement(new Circle(5));
structure.addElement(new Rectangle(4, 6));

const areaVisitor = new AreaCalculator();
structure.accept(areaVisitor);
//Resultado Esperado:
üîµ √Årea del c√≠rculo: 78.54
üü¶ √Årea del rect√°ngulo: 24
        </code></pre>
        </section>

        <section>
          <h3>‚úÖ Ventajas</h3>
          <ul>
            <li>
              Permite agregar operaciones sin modificar las clases existentes.
            </li>
            <li>Fomenta el principio de responsabilidad √∫nica.</li>
            <li>Facilita el mantenimiento de algoritmos complejos.</li>
          </ul>
        </section>

        <section>
          <h3>‚ö†Ô∏è Desventajas</h3>
          <ul>
            <li>
              A√±adir nuevos elementos requiere modificar todos los visitantes
              existentes.
            </li>
            <li>
              Puede romper el principio abierto/cerrado si se cambia con
              frecuencia la jerarqu√≠a de clases.
            </li>
          </ul>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.min.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: [RevealHighlight],
      });
    </script>
  </body>
</html>
