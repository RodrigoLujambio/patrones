<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Patrones de Dise√±o - Presentaci√≥n</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/black.css"
    />
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
    <style>
      section h2 {
        color: #ffd700;
        font-size: 1.5em;
      }
      section h3 {
        color: #00ced1;
        font-size: 1.3em;
      }
      section ul li,
      section p {
        color: #e0e0e0;
        font-size: 0.9em;
      }
      pre code {
        font-size: 0.8em;
      }
      table {
        font-size: 0.9em;
        color: #fff;
      }
      th,
      td {
        padding: 8px 12px;
        border: 1px solid #999;
      }
      table {
        border-collapse: collapse;
        margin: auto;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1 style="color: #7fffd4; font-size: 2em">üåâ Patrones de Dise√±o</h1>
          <p style="color: #d3d3d3; font-size: 1em">
            DAO, Repository, Proxy, Decorator, Facade, Adapter, Bridge
          </p>
        </section>

        <!-- PATRON: Adapter -->
        <section><h2>üîå Adapter</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üîß El patr√≥n Adapter permite que dos interfaces incompatibles
            trabajen juntas. Act√∫a como un puente entre dos clases que no
            podr√≠an interactuar directamente debido a diferencias en sus
            interfaces.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s usar una clase existente pero su interfaz no
              coincide con lo que espera tu c√≥digo.
            </li>
            <li>
              Cuando necesit√°s integrar c√≥digo heredado o de terceros sin
              modificarlo.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li><strong>Target</strong>: La interfaz que espera el cliente.</li>
            <li>
              <strong>Adaptee</strong>: La clase existente con la funcionalidad
              deseada.
            </li>
            <li>
              <strong>Adapter</strong>: Traduce la interfaz de Adaptee a la del
              Target.
            </li>
          </ul>
        </section>

        <section>
          <h3>Clase Target</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Target: interfaz esperada por el cliente
class Printer {
  printMessage(msg) {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Clase Adaptee</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Adaptee: clase ya existente
class LegacyPrinter {
  oldPrint(msg) {
    console.log(">>> " + msg);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Clase Adapter</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Adapter: adapta LegacyPrinter a la interfaz esperada
class PrinterAdapter extends Printer {
  constructor() {
    super();
    this.legacy = new LegacyPrinter();
  }

  printMessage(msg) {
    this.legacy.oldPrint(msg);
  }
}
        </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Cliente usa el adapter sin saber que existe LegacyPrinter
const printer = new PrinterAdapter();
printer.printMessage("Hola mundo");
        </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas y ‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li><strong style="color: #90ee90">‚úÖ Ventajas</strong></li>
            <ul>
              <li>
                Te permite <strong>reutilizar c√≥digo existente</strong> sin
                modificarlo.
              </li>
              <li>A√≠sla cambios en la implementaci√≥n del c√≥digo cliente.</li>
              <li>Facilita la integraci√≥n de librer√≠as o sistemas legados.</li>
            </ul>
            <br />
            <li><strong style="color: #ffd700">‚ö†Ô∏è Desventajas</strong></li>
            <ul>
              <li>
                Puede <strong>agregar complejidad</strong> innecesaria si se
                abusa.
              </li>
              <li>
                En algunos lenguajes, puede implicar una
                <strong>carga extra de herencia o composici√≥n</strong>.
              </li>
            </ul>
          </ul>
        </section>

        <!-- PATRON: Bridge -->
        <section><h2>üåâ Bridge</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üß± El patr√≥n Bridge separa una abstracci√≥n de su implementaci√≥n,
            permitiendo que ambas evolucionen independientemente.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando ten√©s una jerarqu√≠a de clases que podr√≠a crecer en
              m√∫ltiples dimensiones.
            </li>
            <li>
              Cuando quer√©s combinar libremente una abstracci√≥n con diferentes
              implementaciones.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Abstraction</strong>: La interfaz de alto nivel para el
              cliente.
            </li>
            <li>
              <strong>Implementor</strong>: Define la interfaz de
              implementaci√≥n.
            </li>
            <li>
              <strong>ConcreteImplementor</strong>: Implementaciones concretas
              del implementor.
            </li>
            <li>
              <strong>RefinedAbstraction</strong>: Extiende la abstracci√≥n y
              delega a un implementor.
            </li>
          </ul>
        </section>

        <section>
          <h3>Clase Abstraction</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Abstraction: interfaz de alto nivel
class Shape {
  constructor(drawingAPI) {
    this.drawingAPI = drawingAPI;
  }

  draw() {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Clase RefinedAbstraction: Circle</h3>
          <pre><code class="language-js" data-trim data-noescape>
// RefinedAbstraction: extensi√≥n concreta de Shape
class Circle extends Shape {
  constructor(x, y, radius, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  draw() {
    this.drawingAPI.drawCircle(this.x, this.y, this.radius);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Otra RefinedAbstraction: Rect√°ngulo</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Otra forma que usa DrawingAPI
class Rectangle extends Shape {
  constructor(x, y, width, height, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  draw() {
    this.drawingAPI.drawRectangle(this.x, this.y, this.width, this.height);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Clase Implementor</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Implementor: define la interfaz de bajo nivel
class DrawingAPI {
  drawCircle(x, y, radius) {
    throw new Error("Este m√©todo debe ser implementado");
  }
  drawRectangle(x, y, width, height) {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteImplementor: CanvasAPI</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Implementaci√≥n concreta de DrawingAPI
class CanvasAPI extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`Canvas: Dibujo un c√≠rculo en (${x}, ${y}) con radio ${radius}`);
  }
  drawRectangle(x, y, width, height) {
    console.log(`Canvas: Dibujo un rect√°ngulo en (${x}, ${y}) de ${width}x${height}`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteImplementor: SVGAPI</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Otra implementaci√≥n concreta de DrawingAPI
class SVGAPI extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`<circle cx='${x}' cy='${y}' r='${radius}' />`);
  }
  drawRectangle(x, y, width, height) {
    console.log(`<rect x='${x}' y='${y}' width='${width}' height='${height}' />`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Ejemplos de uso</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Usar Circle con CanvasAPI
const canvasCircle = new Circle(10, 20, 5, new CanvasAPI());
canvasCircle.draw();

// Usar Circle con SVGAPI
const svgCircle = new Circle(0, 0, 10, new SVGAPI());
svgCircle.draw();

// Usar Rectangle con CanvasAPI
const rect = new Rectangle(5, 5, 20, 10, new CanvasAPI());
rect.draw();
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Desacopla <strong>abstracci√≥n</strong> e
              <strong>implementaci√≥n</strong>.
            </li>
            <li>
              Permite <strong>combinar libremente</strong> formas y m√©todos de
              renderizado (composici√≥n).
            </li>
            <li>
              Facilita la <strong>extensi√≥n</strong> sin modificar c√≥digo
              existente.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Introduce m√°s <strong>clases y capas</strong> (complejidad
              adicional).
            </li>
            <li>
              Puede parecer <strong>innecesario</strong> si la jerarqu√≠a no es
              grande.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Diferencia clave con Adapter</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Adapter</strong> adapta una interfaz existente para que
              sea compatible.
            </li>
            <li>
              <strong>Bridge</strong> separa dos jerarqu√≠as desde el dise√±o para
              que crezcan de forma independiente.
            </li>
          </ul>
        </section>

        <!-- PATRON: Decorator -->
        <section><h2>üéÅ Decorator</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            ‚ú® El patr√≥n Decorator permite agregar responsabilidades a un objeto
            de forma din√°mica, sin modificar su c√≥digo.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s agregar funcionalidades a objetos en tiempo de
              ejecuci√≥n.
            </li>
            <li>Cuando no pod√©s usar herencia para extender comportamiento.</li>
            <li>
              Cuando quer√©s mantener el principio de abierto/cerrado
              (Open/Closed).
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Component</strong>: Interfaz base que define la operaci√≥n.
            </li>
            <li>
              <strong>ConcreteComponent</strong>: Implementaci√≥n principal de
              esa interfaz.
            </li>
            <li>
              <strong>Decorator</strong>: Clase abstracta que implementa la
              interfaz y tiene una referencia al componente a decorar.
            </li>
            <li>
              <strong>ConcreteDecorators</strong>: Decoradores espec√≠ficos que
              agregan comportamiento.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componente base</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Component
class Notifier {
  send(message) {
    throw new Error("Este m√©todo debe ser implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Componente concreto</h3>
          <pre><code class="language-js" data-trim data-noescape>
// ConcreteComponent
class BasicNotifier extends Notifier {
  send(message) {
    console.log("Enviando mensaje:", message);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Decorator base</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Decorator base
class NotifierDecorator extends Notifier {
  constructor(notifier) {
    super();
    this.notifier = notifier;
  }

  send(message) {
    this.notifier.send(message);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteDecorator: Emoji</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Agrega emojis al mensaje
class EmojiDecorator extends NotifierDecorator {
  send(message) {
    super.send("üòÄ " + message + " üéâ");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>ConcreteDecorator: Timestamp</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Agrega una marca de tiempo
class TimestampDecorator extends NotifierDecorator {
  send(message) {
    const timestamp = new Date().toISOString();
    super.send(`[${timestamp}] ${message}`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
// Composici√≥n din√°mica de decoradores
let notifier = new BasicNotifier();
notifier = new TimestampDecorator(notifier);
notifier = new EmojiDecorator(notifier);

notifier.send("¬°Hola mundo!");
// Resultado esperado:
// Enviando mensaje: üòÄ [2025-06-24T12:00:00.000Z] ¬°Hola mundo! üéâ
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Permite extender funcionalidades de manera flexible y
              <strong>din√°mica</strong>.
            </li>
            <li>
              Elimina la necesidad de
              <strong>crear muchas subclases</strong> para cada combinaci√≥n
              posible.
            </li>
            <li>
              Respeta el <strong>principio de responsabilidad √∫nica</strong>.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede generar <strong>muchos objetos anidados</strong> si se
              abusa.
            </li>
            <li>
              Puede ser m√°s dif√≠cil de <strong>depurar</strong> o entender que
              la herencia simple.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Diferencias con otros patrones</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Decorator vs Adapter</strong>: Adapter cambia la
              <strong>interfaz</strong>; Decorator
              <strong>agrega comportamiento</strong>.
            </li>
          </ul>
        </section>

        <!-- PATRON: Facade -->
        <section><h2>üè¢ Facade</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üéØ El patr√≥n Facade proporciona una interfaz simplificada a un
            conjunto complejo de clases o subsistemas.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>Cuando quer√©s ocultar la complejidad de un sistema interno.</li>
            <li>Cuando quer√©s desacoplar el cliente del sistema interno.</li>
            <li>
              Cuando trabaj√°s con bibliotecas o APIs con muchas dependencias.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li><strong>Facade</strong>: Interfaz de alto nivel.</li>
            <li>
              <strong>Subsistemas</strong>: Clases que hacen el trabajo real.
            </li>
            <li>
              <strong>Cliente</strong>: Usa el Facade en lugar de interactuar
              directamente con los subsistemas.
            </li>
          </ul>
        </section>

        <section>
          <h3>Clases del subsistema üé¨</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Amplifier {
  on() {
    console.log("Amplificador encendido");
  }
}

class StreamingPlayer {
  on() {
    console.log("Reproductor encendido");
  }
  play(movie) {
    console.log(`Reproduciendo ${movie}`);
  }
}

class TheaterLights {
  dim(level) {
    console.log(`Luces atenuadas a ${level}%`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Clase Facade: HomeTheaterFacade üçø</h3>
          <pre><code class="language-js" data-trim data-noescape>
class HomeTheaterFacade {
  constructor(amp, player, lights) {
    this.amp = amp;
    this.player = player;
    this.lights = lights;
  }

  watchMovie(movie) {
    console.log("Preparando para ver una pel√≠cula...");
    this.lights.dim(10);
    this.amp.on();
    this.player.on();
    this.player.play(movie);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Escenario sin Facade ‚ùå</h3>
          <pre><code class="language-js" data-trim data-noescape>
const amp = new Amplifier();
const player = new StreamingPlayer();
const lights = new TheaterLights();

lights.dim(10);
amp.on();
player.on();
player.play("Matrix");
// Dif√≠cil de mantener, propenso a errores,
// y repetitivo cada vez que se quiere reproducir una pel√≠cula
  </code></pre>
        </section>

        <section>
          <h3>Uso con Facade ‚úÖ</h3>
          <pre><code class="language-js" data-trim data-noescape>
const amp = new Amplifier();
const player = new StreamingPlayer();
const lights = new TheaterLights();

const homeTheater = new HomeTheaterFacade(amp, player, lights);
homeTheater.watchMovie("Matrix");

// Resultado:
// Preparando para ver una pel√≠cula...
// Luces atenuadas a 10%
// Amplificador encendido
// Reproductor encendido
// Reproduciendo Matrix
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li><strong>Oculta la complejidad</strong> del sistema.</li>
            <li>
              Reduce el <strong>acoplamiento</strong> entre cliente y
              subsistema.
            </li>
            <li>
              Mejora la <strong>legibilidad y mantenibilidad</strong> del c√≥digo
              cliente.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede convertirse en una <strong>‚Äúclase dios‚Äù</strong> si se
              abusa.
            </li>
            <li>
              No impide al cliente seguir accediendo al subsistema directamente
              (si no se controla).
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Comparaciones</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Facade vs Adapter:</strong>
              <ul>
                <li>
                  <em>Facade</em> simplifica una interfaz
                  <strong>compleja existente</strong>.
                </li>
                <li>
                  <em>Adapter</em> convierte una
                  <strong>interfaz incompatible</strong> en una que el cliente
                  espera.
                </li>
              </ul>
            </li>
            <li>
              <strong>Facade vs Decorator:</strong>
              <ul>
                <li>
                  <em>Decorator</em> a√±ade <strong>comportamiento</strong>.
                </li>
                <li><em>Facade</em> oculta <strong>complejidad</strong>.</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- PATRON: Proxy -->
        <section><h2>üõ°Ô∏è Proxy</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üïµÔ∏è‚Äç‚ôÇÔ∏è El patr√≥n Proxy provee un objeto sustituto que controla el acceso
            a otro objeto.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>Para controlar el acceso a un objeto costoso o sensible.</li>
            <li>
              Para agregar l√≥gica adicional (logs, control de acceso, cache) sin
              modificar el objeto real.
            </li>
            <li>Para cargar objetos de manera diferida (lazy loading).</li>
          </ul>
        </section>

        <section>
          <h3>Tipos de Proxy üîÄ</h3>
          <ul>
            <li>
              <strong>Proxy de protecci√≥n</strong>: Controla permisos de acceso.
            </li>
            <li>
              <strong>Proxy virtual</strong>: Crea objetos costosos bajo
              demanda.
            </li>
            <li>
              <strong>Proxy remoto</strong>: Representa un objeto que est√° en
              otra m√°quina.
            </li>
            <li>
              <strong>Proxy de cach√©</strong>: Guarda resultados para
              reutilizarlos.
            </li>
            <li>
              <strong>Proxy inteligente</strong>: Agrega l√≥gica adicional como
              logging o conteo de referencias.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Subject</strong>: Interfaz com√∫n para el RealSubject y el
              Proxy.
            </li>
            <li>
              <strong>RealSubject</strong>: El objeto real al que se accede.
            </li>
            <li><strong>Proxy</strong>: Controla el acceso al RealSubject.</li>
          </ul>
        </section>

        <section>
          <h3>Interfaz Subject</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Video {
  constructor(filename) {
    this.filename = filename;
    this.load();
  }

  load() {
    console.log(`Cargando video desde ${this.filename}...`);
  }

  play() {
    console.log(`Reproduciendo ${this.filename}`);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Proxy: Proxy que retrasa la carga de video</h3>
          <pre><code class="language-js" data-trim data-noescape>
class VideoProxy {
  constructor(filename) {
    this.filename = filename;
    this.realVideo = null;
  }

  play() {
    if (!this.realVideo) {
      this.realVideo = new Video(this.filename); // carga solo al primer uso
    }
    this.realVideo.play();
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const video = new VideoProxy("pelicula.mp4");
console.log("Video creado pero no cargado a√∫n");
video.play(); // aqu√≠ reci√©n se carga y reproduce
video.play(); // ya est√° cargado, se reproduce directamente
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Permite <strong>controlar el acceso</strong> a objetos costosos o
              sensibles.
            </li>
            <li>
              Agrega <strong>funcionalidad extra</strong> como logs, control de
              acceso o cache.
            </li>
            <li>Permite <strong>lazy loading</strong> (carga diferida).</li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede
              <strong>introducir una capa de complejidad</strong> adicional.
            </li>
            <li>
              Si no est√° bien dise√±ado, puede
              <strong>afectar el rendimiento</strong>.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">üÜö Comparaciones</h3>
          <ul style="font-size: 0.8em">
            <li>
              <strong>Proxy vs Decorator:</strong> Proxy
              <strong>controla acceso</strong>; Decorator
              <strong>agrega comportamiento</strong>.
            </li>
            <li>
              <strong>Proxy vs Adapter:</strong> Adapter
              <strong>transforma interfaces</strong>; Proxy
              <strong>intercepta y decide acceso</strong>.
            </li>
          </ul>
        </section>

        <!-- PATRON: DAO -->
        <section><h2>üìÇ DAO (Data Access Object)</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üìÅ El patr√≥n DAO encapsula el acceso a datos, separando la l√≥gica de
            negocio de la l√≥gica de persistencia.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s desacoplar tu l√≥gica de negocio del acceso a la base
              de datos.
            </li>
            <li>
              Cuando quer√©s facilitar el testeo o intercambiar mecanismos de
              persistencia.
            </li>
            <li>Cuando ten√©s m√∫ltiples fuentes de datos o repositorios.</li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>DAO</strong>: Define los m√©todos para acceder y modificar
              datos.
            </li>
            <li>
              <strong>Entidad</strong>: Representa la estructura de datos.
            </li>
            <li>
              <strong>Implementaci√≥n concreta</strong>: L√≥gica espec√≠fica de
              almacenamiento.
            </li>
            <li>
              <strong>Servicio/Cliente</strong>: Usa el DAO sin saber c√≥mo se
              persisten los datos.
            </li>
          </ul>
        </section>

        <section>
          <h3>Entidad: Usuario</h3>
          <pre><code class="language-js" data-trim data-noescape>
class User {
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Interfaz DAO</h3>
          <pre><code class="language-js" data-trim data-noescape>
class UserDAO {
  getAll() {
    throw new Error("No implementado");
  }
  getById(id) {
    throw new Error("No implementado");
  }
  save(user) {
    throw new Error("No implementado");
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Implementaci√≥n concreta (en memoria)</h3>
          <pre><code class="language-js" data-trim data-noescape>
class InMemoryUserDAO extends UserDAO {
  constructor() {
    super();
    this.users = [];
  }

  getAll() {
    return this.users;
  }

  getById(id) {
    return this.users.find(u => u.id === id);
  }

  save(user) {
    this.users.push(user);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Uso desde el cliente</h3>
          <pre><code class="language-js" data-trim data-noescape>
const dao = new InMemoryUserDAO();

dao.save(new User(1, "Alice"));
dao.save(new User(2, "Bob"));

console.log(dao.getAll());
console.log(dao.getById(2));

// Resultado esperado:
// [ User { id: 1, name: 'Alice' }, User { id: 2, name: 'Bob' } ]
// User { id: 2, name: 'Bob' }
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Separa <strong>l√≥gica de acceso a datos</strong> de la l√≥gica de
              negocio.
            </li>
            <li>Facilita <strong>el testeo</strong> y el mantenimiento.</li>
            <li>
              Permite <strong>cambiar el mecanismo de persistencia</strong> sin
              modificar el resto del sistema.
            </li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>
              Puede resultar en <strong>clases repetitivas</strong> si no se
              abstraen bien.
            </li>
            <li>
              Puede ser <strong>innecesario</strong> en aplicaciones peque√±as o
              muy simples.
            </li>
          </ul>
        </section>

        <!-- PATRON: Repository -->
        <section><h2>üì¶ Repository</h2></section>

        <section>
          <h3>¬øQu√© es?</h3>
          <p>
            üìö El patr√≥n Repository act√∫a como una colecci√≥n en memoria,
            permitiendo acceder a objetos sin exponer detalles de
            almacenamiento. A√≠sla la l√≥gica de acceso a datos del resto de la
            aplicaci√≥n.
          </p>
        </section>

        <section>
          <h3>¬øCu√°ndo usarlo? üß†</h3>
          <ul>
            <li>
              Cuando quer√©s abstraer la l√≥gica de consulta y persistencia.
            </li>
            <li>Cuando trabaj√°s con modelos de dominio complejos.</li>
            <li>
              Cuando quer√©s desacoplar servicios de la l√≥gica de almacenamiento.
            </li>
          </ul>
        </section>

        <section>
          <h3>Componentes principales üß©</h3>
          <ul>
            <li>
              <strong>Repositorio</strong>: Provee operaciones sobre entidades
              del dominio.
            </li>
            <li>
              <strong>Entidad</strong>: Modelo del dominio que se gestiona.
            </li>
            <li>
              <strong>Fuente de datos</strong>: Base de datos, servicio externo,
              o DAO.
            </li>
          </ul>
        </section>

        <section>
          <h3>Entidad: Product</h3>
          <pre><code class="language-js" data-trim data-noescape>
class Product {
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Repositorio sin DAO ‚ùå</h3>
          <pre><code class="language-js" data-trim data-noescape>
class ProductRepository {
  constructor() {
    this.products = [];
  }

  findAll() {
    return this.products;
  }

  findById(id) {
    return this.products.find(p => p.id === id);
  }

  save(product) {
    this.products.push(product);
  }
}

const repo = new ProductRepository();
repo.save(new Product(1, "Silla"));
repo.save(new Product(2, "Mesa"));

console.log(repo.findAll());
console.log(repo.findById(2));
  </code></pre>
        </section>

        <section>
          <h3>DAO para productos</h3>
          <pre><code class="language-js" data-trim data-noescape>
class ProductDAO {
  constructor() {
    this.storage = [];
  }

  getAll() {
    return this.storage;
  }

  getById(id) {
    return this.storage.find(p => p.id === id);
  }

  save(product) {
    this.storage.push(product);
  }
}
  </code></pre>
        </section>

        <section>
          <h3>Repositorio con DAO ‚úÖ</h3>
          <pre><code class="language-js" data-trim data-noescape>

// Repository que usa DAO
class ProductRepository {
  constructor(dao) {
    this.dao = dao;
  }

  getAllProducts() {
    return this.dao.getAll();
  }

  getProductById(id) {
    return this.dao.getById(id);
  }

  addProduct(product) {
    this.dao.save(product);
  }
}

const dao = new ProductDAO();
const repository = new ProductRepository(dao);

repository.addProduct(new Product(1, "L√°mpara"));
repository.addProduct(new Product(2, "Sof√°"));

console.log(repository.getAllProducts());
console.log(repository.getProductById(1));
  </code></pre>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚úÖ Ventajas</h3>
          <ul style="font-size: 0.8em">
            <li>Encapsula la l√≥gica de acceso y consulta.</li>
            <li>
              Ofrece una <strong>API coherente</strong> para trabajar con
              objetos del dominio.
            </li>
            <li>Facilita pruebas y mantenimiento.</li>
          </ul>
        </section>

        <section>
          <h3 style="font-size: 1.1em">‚ö†Ô∏è Desventajas</h3>
          <ul style="font-size: 0.8em">
            <li>Puede duplicar trabajo si ya se usa un ORM sofisticado.</li>
            <li>
              Agrega una capa m√°s que puede <strong>no ser necesaria</strong> en
              sistemas simples.
            </li>
          </ul>
        </section>

        <!-- Aqu√≠ seguir√°n los dem√°s patrones -->
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.min.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: [RevealHighlight],
      });
    </script>
  </body>
</html>
